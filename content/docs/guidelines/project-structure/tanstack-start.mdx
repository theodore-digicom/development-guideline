---
title: "Project Structuring with TanStack Start"
---
## The TanStack Start Project Structure Blueprint: From `__root.tsx` to Scalable Applications

### Introduction: Why Structure Matters in the TanStack Ecosystem

You've mastered the structured, file-based conventions of Next.js. Now, as you explore **TanStack Start**, you'll find a powerful, full-stack framework that offers a different philosophy: extreme flexibility with uncompromising type-safety. TanStack Start doesn't lock you into a single way of doing things; instead, it provides powerful primitives—like its best-in-class, file-based router and trusts you to architect your application logically.

This guide can be your blueprint. We will translate the structured thinking from Next.js to the modular, type-safe world of TanStack. The goal is not just to make it work, but to build a foundation that remains clean, navigable, and scalable as your team and feature set grow.

### Part 1: Routing & Layouts – The Foundation of Your App

TanStack Router's file-based routing is its flagship feature, offering type-safety that permeates your entire application. Understanding its conventions is the first step to a clean structure.

#### **Core Routing Conventions**
All routes live in a dedicated directory, typically `src/routes/`. The router interprets your file and folder names to generate a type-safe route tree. You have two primary patterns: **Directory Routes** and **Flat Routes**, and you are encouraged to mix them.

*   **`__root.tsx`**: This is your application's root layout, analogous to `app/layout.tsx` in Next.js. It wraps *every* page.
*   **`index.tsx`**: Represents the route of its containing directory (e.g., `src/routes/index.tsx` is your homepage `/`).
*   **Dynamic Segments**: Prefix a filename with `$` (e.g., `$postId.tsx` for `/posts/123`).
*   **Private Files and Folders**: Prefix a folder or file name with `_` (e.g., `_private.tsx` for `/_private`).
*   **Layout Routes**: if you wanna create a layout for `/dashboard` you can do so by createing file (e.g., `./routes/dashboard.tsx`). This creates a layout component that wraps all child routes of `/dashboard`.

#### **Project Structure in Practice: Layouts & Nested Routes**

Let's build a common structure with authentication, a public marketing site, and a protected dashboard.

**Using Directory Routes (Clear Separation)**
```
src/routes/
├── __root.tsx                    # Global layout (e.g., <html>, <body>)
├── index.tsx                     # Public homepage at `/`
├── about.tsx                     # `/about`
├── (auth)                        # Route group for organization
│   ├── _auth.tsx                 # Layout for sign-in/sign-up pages
│   ├── _auth.sign-in.tsx         # `/sign-in`
│   └── _auth.sign-up.tsx         # `/sign-up`
├── _dashboard.tsx                # Main dashboard layout (e.g., with sidebar)
├── dashboard/                    # `/dashboard/*` routes
│   ├── index.tsx                 # `/dashboard`
│   ├── analytics.tsx             # `/dashboard/analytics`
│   └── user/
│       ├── $userId.tsx           # `/dashboard/user/123`
│       └── $userId.edit.tsx      # `/dashboard/user/123/edit`
└── blog/
    ├── index.tsx                 # `/blog`
    └── $slug.tsx                 # `/blog/my-post-title`
```


#### **Code Example: Implementing a Layout Route**
Here is how you define a layout route like `dashboard.tsx`. It uses `<Outlet />` to render its child pages.

```tsx
// src/routes/dashboard.tsx
import { createFileRoute, Outlet } from '@tanstack/react-router'
import { DashboardSidebar } from '@/components/dashboard/sidebar'

// This creates a layout route. Its path is not in the URL.
export const Route = createFileRoute('/dashboard')({
  component: DashboardLayout,
})

function DashboardLayout() {
  return (
    <div className="flex h-screen">
      <DashboardSidebar />
      <main className="flex-1 p-6">
        {/* Child routes (e.g., /dashboard, /dashboard/analytics) render here */}
        <Outlet />
      </main>
    </div>
  )
}
```

TanStack Start is great because everything is separate. Routing is handled by TanStack Router, and if you want to learn more about it, you can read the [Tanstack Router Docs](https://tanstack.com/router/latest/docs/framework/react/overview).

### Part 2: Structuring Components, Hooks & Utilities

Once routing is set up, we structure our UI and logic. The main idea is to keep related things together and make it clear what owns what.

#### **Component Architecture**
*   **Global/Shared UI Components (`/components/ui/`)**: Reusable, presentational primitives (Button, Card, Dialog). Consider using a component library like Shadcn/ui here.
*   **Feature Components (`/features/`)**: Components specific to a business domain (UserProfile, BillingHistory). Co-locate them *close to their route*.
*   **Layout Components (`/components/layouts/`)**: Larger structural components (MainNav, Footer, Sidebar) used in layout files.

#### **Recommended Project Structure**
A feature-based layout that scales well for larger apps:
```
src/
├── routes/                      # File-based routes
├── apis/                        # API client, React Query setup, types, requests
├── features/                    # Domain-specific logic
│   ├── auth/
│   │   ├── components/          # SignInForm, SignUpForm
│   │   ├── hooks/               # useAuth, useSession
│   │   ├── schemas/             # Zod validation
│   │   └── api/                 # Queries/mutations for auth
│   └── dashboard/
│       ├── analytics/
│       │   └── components/      # Charts, MetricCards
│       └── user/
│           └── hooks/           # useUserProfile
├── components/
│   ├── ui/                      # Reusable primitives
│   ├── layouts/                 # Nav, Footer
│   └── shared/                  # Cross-feature components
├── hooks/                       # Global reusable hooks
├── lib/                         # Config, constants, utilities
├── api/                         # API clients, tRPC/OpenAPI types
├── db/                          # TanStackDB/RxDB schemas (optional)
└── styles/                      # Global CSS, Tailwind
```

**Key idea**: Put all business logic inside features. 
<br/>Import what you need into the route files don't scatter domain code everywhere.

#### Hook & State Management Strategy
TanStack Start works best with a layered state model:
1. **Local State:** `useState` for small UI concerns (e.g., toggles, modals).
2. **Form State:** `useForm` from **React Hook Form** for form management.
3. **Server State:** **TanStack Query is the default choice.** It handles fetching, caching, and synchronizing remote data fetching, caching, syncing.
4. **Global UI State:** If needed (theme, sidebar, global dialogs), use **Zustand**. Avoid using Context for frequently changing values.

> You can find more detailed explanations in the next page, where we talk about [Choosing the Right Tool](/docs/guidelines/state-management).


### Key Architectural Decisions & Best Practices Summary

1.  **Start with Vite:** TanStack Start uses Vite under the hood. It's the modern, fast standard for React tooling.
2.  **Type Everything:** Use TypeScript. TanStack Router's file-based routing generates type-safe pathnames and search params, which is a core selling point.
3.  **Embrace Feature-Based Organization:** Group files by what they *do* (auth, dashboard) rather than by *type* (components, hooks). This is the most scalable approach.
4.  **Leverage Route Groups (`()`) for Code Organization:** Keep related routes (like all auth pages) together in the filesystem without affecting the user's browser URL.

#### **Comparison: TanStack Start vs. Next.js Mindset**
| Concept | Next.js (App Router) | TanStack Start |
| :--- | :--- | :--- |
| **Layout File** | `layout.tsx` inside a folder | `layoutName.tsx` as a sibling to the route file |
| **Private Folders** | none | `_folderName` route groups |
| **Data Fetching** | `async` component, TanStack Query loaders, mutations, Server Actions | TanStack Query loaders, mutations |
| **Type Safety** | Good (with TypeScript) | **Excellent** (router-generated types) |
| **Philosophy** | Convention & integrated full-stack | Modularity & library flexibility |

This structure provides maintainable foundation for your TanStack Start project. By separating concerns, leveraging the powerful router, and adopting modern state management patterns, you can build applications that are as enjoyable to maintain as they are to use.